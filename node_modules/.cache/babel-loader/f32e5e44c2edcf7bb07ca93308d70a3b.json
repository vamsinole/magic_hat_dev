{"ast":null,"code":"import _toConsumableArray from \"/Users/vamshikrishnaenjapuri/Documents/secretalphanew/secret_alpha_ts/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"/Users/vamshikrishnaenjapuri/Documents/secretalphanew/secret_alpha_ts/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/vamshikrishnaenjapuri/Documents/secretalphanew/secret_alpha_ts/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/vamshikrishnaenjapuri/Documents/secretalphanew/secret_alpha_ts/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vamshikrishnaenjapuri/Documents/secretalphanew/secret_alpha_ts/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/vamshikrishnaenjapuri/Documents/secretalphanew/secret_alpha_ts/node_modules/@babel/runtime/regenerator/index.js\";\nimport * as assert from \"assert\";\nvar LOG_START_INDEX = \"Program log: \".length;\nexport var EventManager = /*#__PURE__*/function () {\n  function EventManager(programId, provider, coder) {\n    _classCallCheck(this, EventManager);\n\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n\n  _createClass(EventManager, [{\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, callback) {\n      var _this = this;\n\n      var listener = this._listenerIdCount;\n      this._listenerIdCount += 1; // Store the listener into the event map.\n\n      if (!(eventName in this._eventCallbacks)) {\n        this._eventListeners.set(eventName, []);\n      }\n\n      this._eventListeners.set(eventName, this._eventListeners.get(eventName).concat(listener)); // Store the callback into the listener map.\n\n\n      this._eventCallbacks.set(listener, [eventName, callback]); // Create the subscription singleton, if needed.\n\n\n      if (this._onLogsSubscriptionId !== undefined) {\n        return listener;\n      }\n\n      this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, function (logs, ctx) {\n        if (logs.err) {\n          console.error(logs);\n          return;\n        }\n\n        _this._eventParser.parseLogs(logs.logs, function (event) {\n          var allListeners = _this._eventListeners.get(event.name);\n\n          if (allListeners) {\n            allListeners.forEach(function (listener) {\n              var _this$_eventCallbacks = _this._eventCallbacks.get(listener),\n                  _this$_eventCallbacks2 = _slicedToArray(_this$_eventCallbacks, 2),\n                  callback = _this$_eventCallbacks2[1];\n\n              callback(event.data, ctx.slot);\n            });\n          }\n        });\n      });\n      return listener;\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(listener) {\n        var callback, _callback, eventName, listeners;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Get the callback.\n                callback = this._eventCallbacks.get(listener);\n\n                if (callback) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Event listener \".concat(listener, \" doesn't exist!\"));\n\n              case 3:\n                _callback = _slicedToArray(callback, 1), eventName = _callback[0]; // Get the listeners.\n\n                listeners = this._eventListeners.get(eventName);\n\n                if (listeners) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Event listeners don't exist for \".concat(eventName, \"!\"));\n\n              case 7:\n                // Update both maps.\n                this._eventCallbacks.delete(listener);\n\n                listeners = listeners.filter(function (l) {\n                  return l !== listener;\n                });\n\n                if (listeners.length === 0) {\n                  this._eventListeners.delete(eventName);\n                } // Kill the websocket connection if all listeners have been removed.\n\n\n                if (!(this._eventCallbacks.size == 0)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                assert.ok(this._eventListeners.size === 0);\n                _context.next = 14;\n                return this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n\n              case 14:\n                this._onLogsSubscriptionId = undefined;\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function removeEventListener(_x) {\n        return _removeEventListener.apply(this, arguments);\n      }\n\n      return removeEventListener;\n    }()\n  }]);\n\n  return EventManager;\n}();\nexport var EventParser = /*#__PURE__*/function () {\n  function EventParser(programId, coder) {\n    _classCallCheck(this, EventParser);\n\n    this.coder = coder;\n    this.programId = programId;\n  } // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n\n\n  _createClass(EventParser, [{\n    key: \"parseLogs\",\n    value: function parseLogs(logs, callback) {\n      var logScanner = new LogScanner(logs);\n      var execution = new ExecutionContext(logScanner.next());\n      var log = logScanner.next();\n\n      while (log !== null) {\n        var _this$handleLog = this.handleLog(execution, log),\n            _this$handleLog2 = _slicedToArray(_this$handleLog, 3),\n            event = _this$handleLog2[0],\n            newProgram = _this$handleLog2[1],\n            didPop = _this$handleLog2[2];\n\n        if (event) {\n          callback(event);\n        }\n\n        if (newProgram) {\n          execution.push(newProgram);\n        }\n\n        if (didPop) {\n          execution.pop();\n        }\n\n        log = logScanner.next();\n      }\n    } // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n\n  }, {\n    key: \"handleLog\",\n    value: function handleLog(execution, log) {\n      // Executing program is this program.\n      if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n        return this.handleProgramLog(log);\n      } // Executing program is not this program.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    } // Handles logs from *this* program.\n\n  }, {\n    key: \"handleProgramLog\",\n    value: function handleProgramLog(log) {\n      // This is a `msg!` log.\n      if (log.startsWith(\"Program log:\")) {\n        var logStr = log.slice(LOG_START_INDEX);\n        var event = this.coder.events.decode(logStr);\n        return [event, null, false];\n      } // System log.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    } // Handles logs when the current program being executing is *not* this.\n\n  }, {\n    key: \"handleSystemLog\",\n    value: function handleSystemLog(log) {\n      // System component.\n      var logStart = log.split(\":\")[0]; // Did the program finish executing?\n\n      if (logStart.match(/^Program (.*) success/g) !== null) {\n        return [null, true]; // Recursive call.\n      } else if (logStart.startsWith(\"Program \".concat(this.programId.toString(), \" invoke\"))) {\n        return [this.programId.toString(), false];\n      } // CPI call.\n      else if (logStart.includes(\"invoke\")) {\n        return [\"cpi\", false]; // Any string will do.\n      } else {\n        return [null, false];\n      }\n    }\n  }]);\n\n  return EventParser;\n}(); // Stack frame execution context, allowing one to track what program is\n// executing for a given log.\n\nvar ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext(log) {\n    _classCallCheck(this, ExecutionContext);\n\n    // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n    var program = /^Program (.*) invoke.*$/g.exec(log)[1];\n    this.stack = [program];\n  }\n\n  _createClass(ExecutionContext, [{\n    key: \"program\",\n    value: function program() {\n      assert.ok(this.stack.length > 0);\n      return this.stack[this.stack.length - 1];\n    }\n  }, {\n    key: \"push\",\n    value: function push(newProgram) {\n      this.stack.push(newProgram);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      assert.ok(this.stack.length > 0);\n      this.stack.pop();\n    }\n  }]);\n\n  return ExecutionContext;\n}();\n\nvar LogScanner = /*#__PURE__*/function () {\n  function LogScanner(logs) {\n    _classCallCheck(this, LogScanner);\n\n    this.logs = logs;\n  }\n\n  _createClass(LogScanner, [{\n    key: \"next\",\n    value: function next() {\n      if (this.logs.length === 0) {\n        return null;\n      }\n\n      var l = this.logs[0];\n      this.logs = this.logs.slice(1);\n      return l;\n    }\n  }]);\n\n  return LogScanner;\n}();","map":{"version":3,"mappings":";;;;;;AACA,OAAO,KAAKA,MAAZ,MAAwB,QAAxB;AAIA,IAAMC,eAAe,GAAG,gBAAgBC,MAAxC;AAUA,WAAaC,YAAb;EAoCE,sBAAYC,SAAZ,EAAkCC,QAAlC,EAAsDC,KAAtD,EAAkE;IAAA;;IAChE,KAAKC,UAAL,GAAkBH,SAAlB;IACA,KAAKI,SAAL,GAAiBH,QAAjB;IACA,KAAKI,YAAL,GAAoB,IAAIC,WAAJ,CAAgBN,SAAhB,EAA2BE,KAA3B,CAApB;IACA,KAAKK,eAAL,GAAuB,IAAIC,GAAJ,EAAvB;IACA,KAAKC,eAAL,GAAuB,IAAID,GAAJ,EAAvB;IACA,KAAKE,gBAAL,GAAwB,CAAxB;EACD;;EA3CH;IAAA;IAAA,OA6CS,0BACLC,SADK,EAELC,QAFK,EAEuC;MAAA;;MAE5C,IAAIC,QAAQ,GAAG,KAAKH,gBAApB;MACA,KAAKA,gBAAL,IAAyB,CAAzB,CAH4C,CAK5C;;MACA,IAAI,EAAEC,SAAS,IAAI,KAAKJ,eAApB,CAAJ,EAA0C;QACxC,KAAKE,eAAL,CAAqBK,GAArB,CAAyBH,SAAzB,EAAoC,EAApC;MACD;;MACD,KAAKF,eAAL,CAAqBK,GAArB,CACEH,SADF,EAEE,KAAKF,eAAL,CAAqBM,GAArB,CAAyBJ,SAAzB,EAAoCK,MAApC,CAA2CH,QAA3C,CAFF,EAT4C,CAc5C;;;MACA,KAAKN,eAAL,CAAqBO,GAArB,CAAyBD,QAAzB,EAAmC,CAACF,SAAD,EAAYC,QAAZ,CAAnC,EAf4C,CAiB5C;;;MACA,IAAI,KAAKK,qBAAL,KAA+BC,SAAnC,EAA8C;QAC5C,OAAOL,QAAP;MACD;;MAED,KAAKI,qBAAL,GAA6B,KAAKb,SAAL,CAAee,UAAf,CAA0BC,MAA1B,CAC3B,KAAKjB,UADsB,EAE3B,UAACkB,IAAD,EAAOC,GAAP,EAAc;QACZ,IAAID,IAAI,CAACE,GAAT,EAAc;UACZC,OAAO,CAACC,KAAR,CAAcJ,IAAd;UACA;QACD;;QACD,KAAI,CAAChB,YAAL,CAAkBqB,SAAlB,CAA4BL,IAAI,CAACA,IAAjC,EAAuC,UAACM,KAAD,EAAU;UAC/C,IAAMC,YAAY,GAAG,KAAI,CAACnB,eAAL,CAAqBM,GAArB,CAAyBY,KAAK,CAACE,IAA/B,CAArB;;UACA,IAAID,YAAJ,EAAkB;YAChBA,YAAY,CAACE,OAAb,CAAqB,UAACjB,QAAD,EAAa;cAChC,4BAAqB,KAAI,CAACN,eAAL,CAAqBQ,GAArB,CAAyBF,QAAzB,CAArB;cAAA;cAAA,IAASD,QAAT;;cACAA,QAAQ,CAACe,KAAK,CAACI,IAAP,EAAaT,GAAG,CAACU,IAAjB,CAAR;YACD,CAHD;UAID;QACF,CARD;MASD,CAhB0B,CAA7B;MAmBA,OAAOnB,QAAP;IACD;EAzFH;IAAA;IAAA;MAAA,oFA2FS,iBAA0BA,QAA1B;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACL;gBACMD,QAFD,GAEY,KAAKL,eAAL,CAAqBQ,GAArB,CAAyBF,QAAzB,CAFZ;;gBAAA,IAGAD,QAHA;kBAAA;kBAAA;gBAAA;;gBAAA,MAIG,IAAIqB,KAAJ,0BAA4BpB,QAA5B,qBAJH;;cAAA;gBAAA,2BAMeD,QANf,MAMED,SANF,iBAQL;;gBACIuB,SATC,GASW,KAAKzB,eAAL,CAAqBM,GAArB,CAAyBJ,SAAzB,CATX;;gBAAA,IAUAuB,SAVA;kBAAA;kBAAA;gBAAA;;gBAAA,MAWG,IAAID,KAAJ,2CAA6CtB,SAA7C,OAXH;;cAAA;gBAcL;gBACA,KAAKJ,eAAL,CAAqB4B,MAArB,CAA4BtB,QAA5B;;gBACAqB,SAAS,GAAGA,SAAS,CAACE,MAAV,CAAiB,UAACC,CAAD;kBAAA,OAAOA,CAAC,KAAKxB,QAAb;gBAAA,CAAjB,CAAZ;;gBACA,IAAIqB,SAAS,CAACpC,MAAV,KAAqB,CAAzB,EAA4B;kBAC1B,KAAKW,eAAL,CAAqB0B,MAArB,CAA4BxB,SAA5B;gBACD,CAnBI,CAqBL;;;gBArBK,MAsBD,KAAKJ,eAAL,CAAqB+B,IAArB,IAA6B,CAtB5B;kBAAA;kBAAA;gBAAA;;gBAuBH1C,MAAM,CAAC2C,EAAP,CAAU,KAAK9B,eAAL,CAAqB6B,IAArB,KAA8B,CAAxC;gBAvBG;gBAAA,OAwBG,KAAKlC,SAAL,CAAee,UAAf,CAA0BqB,oBAA1B,CACJ,KAAKvB,qBADD,CAxBH;;cAAA;gBA2BH,KAAKA,qBAAL,GAA6BC,SAA7B;;cA3BG;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CA3FT;;MAAA;QAAA;MAAA;;MAAA;IAAA;EAAA;;EAAA;AAAA;AA2HA,WAAaZ,WAAb;EAIE,qBAAYN,SAAZ,EAAkCE,KAAlC,EAA8C;IAAA;;IAC5C,KAAKA,KAAL,GAAaA,KAAb;IACA,KAAKF,SAAL,GAAiBA,SAAjB;EACD,CAPH,CASE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EAnBF;IAAA;IAAA,OAoBS,mBAAUqB,IAAV,EAA0BT,QAA1B,EAAwD;MAC7D,IAAM6B,UAAU,GAAG,IAAIC,UAAJ,CAAerB,IAAf,CAAnB;MACA,IAAMsB,SAAS,GAAG,IAAIC,gBAAJ,CAAqBH,UAAU,CAACI,IAAX,EAArB,CAAlB;MACA,IAAIC,GAAG,GAAGL,UAAU,CAACI,IAAX,EAAV;;MACA,OAAOC,GAAG,KAAK,IAAf,EAAqB;QACnB,sBAAkC,KAAKC,SAAL,CAAeJ,SAAf,EAA0BG,GAA1B,CAAlC;QAAA;QAAA,IAAKnB,KAAL;QAAA,IAAYqB,UAAZ;QAAA,IAAwBC,MAAxB;;QACA,IAAItB,KAAJ,EAAW;UACTf,QAAQ,CAACe,KAAD,CAAR;QACD;;QACD,IAAIqB,UAAJ,EAAgB;UACdL,SAAS,CAACO,IAAV,CAAeF,UAAf;QACD;;QACD,IAAIC,MAAJ,EAAY;UACVN,SAAS,CAACQ,GAAV;QACD;;QACDL,GAAG,GAAGL,UAAU,CAACI,IAAX,EAAN;MACD;IACF,CArCH,CAuCE;IACA;IACA;IACA;;EA1CF;IAAA;IAAA,OA2CU,mBACNF,SADM,EAENG,GAFM,EAEK;MAEX;MACA,IACEH,SAAS,CAACS,KAAV,CAAgBtD,MAAhB,GAAyB,CAAzB,IACA6C,SAAS,CAACU,OAAV,OAAwB,KAAKrD,SAAL,CAAesD,QAAf,EAF1B,EAGE;QACA,OAAO,KAAKC,gBAAL,CAAsBT,GAAtB,CAAP;MACD,CALD,CAMA;MANA,KAOK;QACH,QAAQ,IAAR,4BAAiB,KAAKU,eAAL,CAAqBV,GAArB,CAAjB;MACD;IACF,CA1DH,CA4DE;;EA5DF;IAAA;IAAA,OA6DU,0BACNA,GADM,EACK;MAEX;MACA,IAAIA,GAAG,CAACW,UAAJ,CAAe,cAAf,CAAJ,EAAoC;QAClC,IAAMC,MAAM,GAAGZ,GAAG,CAACa,KAAJ,CAAU9D,eAAV,CAAf;QACA,IAAM8B,KAAK,GAAG,KAAKzB,KAAL,CAAW0D,MAAX,CAAkBC,MAAlB,CAAyBH,MAAzB,CAAd;QACA,OAAO,CAAC/B,KAAD,EAAQ,IAAR,EAAc,KAAd,CAAP;MACD,CAJD,CAKA;MALA,KAMK;QACH,QAAQ,IAAR,4BAAiB,KAAK6B,eAAL,CAAqBV,GAArB,CAAjB;MACD;IACF,CA1EH,CA4EE;;EA5EF;IAAA;IAAA,OA6EU,yBAAgBA,GAAhB,EAA2B;MACjC;MACA,IAAMgB,QAAQ,GAAGhB,GAAG,CAACiB,KAAJ,CAAU,GAAV,EAAe,CAAf,CAAjB,CAFiC,CAIjC;;MACA,IAAID,QAAQ,CAACE,KAAT,CAAe,wBAAf,MAA6C,IAAjD,EAAuD;QACrD,OAAO,CAAC,IAAD,EAAO,IAAP,CAAP,CADqD,CAErD;MACD,CAHD,MAGO,IACLF,QAAQ,CAACL,UAAT,mBAA+B,KAAKzD,SAAL,CAAesD,QAAf,EAA/B,aADK,EAEL;QACA,OAAO,CAAC,KAAKtD,SAAL,CAAesD,QAAf,EAAD,EAA4B,KAA5B,CAAP;MACD,CAJM,CAKP;MALO,KAMF,IAAIQ,QAAQ,CAACG,QAAT,CAAkB,QAAlB,CAAJ,EAAiC;QACpC,OAAO,CAAC,KAAD,EAAQ,KAAR,CAAP,CADoC,CACb;MACxB,CAFI,MAEE;QACL,OAAO,CAAC,IAAD,EAAO,KAAP,CAAP;MACD;IACF;EAhGH;;EAAA;AAAA,I,CAmGA;AACA;;IACMrB,gB;EAGJ,0BAAYE,GAAZ,EAAuB;IAAA;;IACrB;IACA;IACA,IAAMO,OAAO,GAAG,2BAA2Ba,IAA3B,CAAgCpB,GAAhC,EAAqC,CAArC,CAAhB;IACA,KAAKM,KAAL,GAAa,CAACC,OAAD,CAAb;EACD;;;;WAED,mBAAO;MACLzD,MAAM,CAAC2C,EAAP,CAAU,KAAKa,KAAL,CAAWtD,MAAX,GAAoB,CAA9B;MACA,OAAO,KAAKsD,KAAL,CAAW,KAAKA,KAAL,CAAWtD,MAAX,GAAoB,CAA/B,CAAP;IACD;;;WAED,cAAKkD,UAAL,EAAuB;MACrB,KAAKI,KAAL,CAAWF,IAAX,CAAgBF,UAAhB;IACD;;;WAED,eAAG;MACDpD,MAAM,CAAC2C,EAAP,CAAU,KAAKa,KAAL,CAAWtD,MAAX,GAAoB,CAA9B;MACA,KAAKsD,KAAL,CAAWD,GAAX;IACD;;;;;;IAGGT,U;EACJ,oBAAmBrB,IAAnB,EAAiC;IAAA;;IAAd;EAAkB;;;;WAErC,gBAAI;MACF,IAAI,KAAKA,IAAL,CAAUvB,MAAV,KAAqB,CAAzB,EAA4B;QAC1B,OAAO,IAAP;MACD;;MACD,IAAIuC,CAAC,GAAG,KAAKhB,IAAL,CAAU,CAAV,CAAR;MACA,KAAKA,IAAL,GAAY,KAAKA,IAAL,CAAUsC,KAAV,CAAgB,CAAhB,CAAZ;MACA,OAAOtB,CAAP;IACD","names":["assert","LOG_START_INDEX","length","EventManager","programId","provider","coder","_programId","_provider","_eventParser","EventParser","_eventCallbacks","Map","_eventListeners","_listenerIdCount","eventName","callback","listener","set","get","concat","_onLogsSubscriptionId","undefined","connection","onLogs","logs","ctx","err","console","error","parseLogs","event","allListeners","name","forEach","data","slot","Error","listeners","delete","filter","l","size","ok","removeOnLogsListener","logScanner","LogScanner","execution","ExecutionContext","next","log","handleLog","newProgram","didPop","push","pop","stack","program","toString","handleProgramLog","handleSystemLog","startsWith","logStr","slice","events","decode","logStart","split","match","includes","exec"],"sourceRoot":"","sources":["../../../src/program/event.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}