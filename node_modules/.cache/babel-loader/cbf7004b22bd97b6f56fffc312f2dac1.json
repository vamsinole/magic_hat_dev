{"ast":null,"code":"import _objectSpread from \"/Users/vamshikrishnaenjapuri/Documents/magic_hat_tshht/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/vamshikrishnaenjapuri/Documents/magic_hat_tshht/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/vamshikrishnaenjapuri/Documents/magic_hat_tshht/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vamshikrishnaenjapuri/Documents/magic_hat_tshht/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\n\nexport var SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\n\nexport var SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\n\nexport var InstructionCoder = /*#__PURE__*/function () {\n  function InstructionCoder(idl) {\n    var _this = this;\n\n    _classCallCheck(this, InstructionCoder);\n\n    this.idl = idl;\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    var sighashLayouts = new Map();\n    idl.instructions.forEach(function (ix) {\n      var sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: _this.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n\n    if (idl.state) {\n      idl.state.methods.map(function (ix) {\n        var sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: _this.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n\n\n  _createClass(InstructionCoder, [{\n    key: \"encode\",\n    value: function encode(ixName, ix) {\n      return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n\n  }, {\n    key: \"encodeState\",\n    value: function encodeState(ixName, ix) {\n      return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n  }, {\n    key: \"_encode\",\n    value: function _encode(nameSpace, ixName, ix) {\n      var buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n      var methodName = camelCase(ixName);\n      var len = this.ixLayout.get(methodName).encode(ix, buffer);\n      var data = buffer.slice(0, len);\n      return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n  }, {\n    key: \"decode\",\n    value:\n    /**\n     * Dewcodes a program instruction.\n     */\n    function decode(ix) {\n      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"hex\";\n\n      if (typeof ix === \"string\") {\n        ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n      }\n\n      var sighash = bs58.encode(ix.slice(0, 8));\n      var data = ix.slice(8);\n      var decoder = this.sighashLayouts.get(sighash);\n\n      if (!decoder) {\n        return null;\n      }\n\n      return {\n        data: decoder.layout.decode(data),\n        name: decoder.name\n      };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(ix, accountMetas) {\n      return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n  }], [{\n    key: \"parseIxLayout\",\n    value: function parseIxLayout(idl) {\n      var stateMethods = idl.state ? idl.state.methods : [];\n      var ixLayouts = stateMethods.map(function (m) {\n        var fieldLayouts = m.args.map(function (arg) {\n          var _a, _b;\n\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }).concat(idl.instructions.map(function (ix) {\n        var fieldLayouts = ix.args.map(function (arg) {\n          var _a, _b;\n\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(ix.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      })); // @ts-ignore\n\n      return new Map(ixLayouts);\n    }\n  }]);\n\n  return InstructionCoder;\n}();\n\nvar InstructionFormatter = /*#__PURE__*/function () {\n  function InstructionFormatter() {\n    _classCallCheck(this, InstructionFormatter);\n  }\n\n  _createClass(InstructionFormatter, null, [{\n    key: \"format\",\n    value: function format(ix, accountMetas, idl) {\n      var idlIx = idl.instructions.filter(function (i) {\n        return ix.name === i.name;\n      })[0];\n\n      if (idlIx === undefined) {\n        console.error(\"Invalid instruction given\");\n        return null;\n      }\n\n      var args = idlIx.args.map(function (idlField) {\n        return {\n          name: idlField.name,\n          type: InstructionFormatter.formatIdlType(idlField.type),\n          data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n        };\n      });\n      var flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n      var accounts = accountMetas.map(function (meta, idx) {\n        if (idx < flatIdlAccounts.length) {\n          return _objectSpread({\n            name: flatIdlAccounts[idx].name\n          }, meta);\n        } // \"Remaining accounts\" are unnamed in Anchor.\n        else {\n          return _objectSpread({\n            name: undefined\n          }, meta);\n        }\n      });\n      return {\n        args: args,\n        accounts: accounts\n      };\n    }\n  }, {\n    key: \"formatIdlType\",\n    value: function formatIdlType(idlType) {\n      if (typeof idlType === \"string\") {\n        return idlType;\n      } // @ts-ignore\n\n\n      if (idlType.vec) {\n        // @ts-ignore\n        return \"Vec<\".concat(this.formatIdlType(idlType.vec), \">\");\n      } // @ts-ignore\n\n\n      if (idlType.option) {\n        // @ts-ignore\n        return \"Option<\".concat(this.formatIdlType(idlType.option), \">\");\n      } // @ts-ignore\n\n\n      if (idlType.defined) {\n        // @ts-ignore\n        return idlType.defined;\n      }\n    }\n  }, {\n    key: \"formatIdlData\",\n    value: function formatIdlData(idlField, data, types) {\n      var _this2 = this;\n\n      if (typeof idlField.type === \"string\") {\n        return data.toString();\n      } // @ts-ignore\n\n\n      if (idlField.type.vec) {\n        // @ts-ignore\n        return \"[\" + data // @ts-ignore\n        .map(function (d) {\n          return _this2.formatIdlData( // @ts-ignore\n          {\n            name: \"\",\n            type: idlField.type.vec\n          }, d);\n        }).join(\", \") + \"]\";\n      } // @ts-ignore\n\n\n      if (idlField.type.option) {\n        // @ts-ignore\n        return data === null ? \"null\" : this.formatIdlData( // @ts-ignore\n        {\n          name: \"\",\n          type: idlField.type.option\n        }, data);\n      } // @ts-ignore\n\n\n      if (idlField.type.defined) {\n        if (types === undefined) {\n          throw new Error(\"User defined types not provided\");\n        } // @ts-ignore\n\n\n        var filtered = types.filter(function (t) {\n          return t.name === idlField.type.defined;\n        });\n\n        if (filtered.length !== 1) {\n          // @ts-ignore\n          throw new Error(\"Type not found: \".concat(idlField.type.defined));\n        }\n\n        return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n      }\n\n      return \"unknown\";\n    }\n  }, {\n    key: \"formatIdlDataDefined\",\n    value: function formatIdlDataDefined(typeDef, data, types) {\n      if (typeDef.type.kind === \"struct\") {\n        var fields = Object.keys(data).map(function (k) {\n          var f = typeDef.type.fields.filter(function (f) {\n            return f.name === k;\n          })[0];\n\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n\n          return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n        }).join(\", \");\n        return \"{ \" + fields + \" }\";\n      } else {\n        if (typeDef.type.variants.length === 0) {\n          return \"{}\";\n        } // Struct enum.\n\n\n        if (typeDef.type.variants[0].name) {\n          var variant = Object.keys(data)[0];\n          var enumType = data[variant];\n          var namedFields = Object.keys(enumType).map(function (f) {\n            var _a;\n\n            var fieldData = enumType[f];\n            var idlField = (_a = typeDef.type.variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(function (v) {\n              return v.name === f;\n            })[0];\n\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n\n            return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n          }).join(\", \");\n          var variantName = camelCase(variant, {\n            pascalCase: true\n          });\n\n          if (namedFields.length === 0) {\n            return variantName;\n          }\n\n          return \"\".concat(variantName, \" { \").concat(namedFields, \" }\");\n        } // Tuple enum.\n        else {\n          // TODO.\n          return \"Tuple formatting not yet implemented\";\n        }\n      }\n    }\n  }, {\n    key: \"flattenIdlAccounts\",\n    value: function flattenIdlAccounts(accounts, prefix) {\n      // @ts-ignore\n      return accounts.map(function (account) {\n        var accName = sentenceCase(account.name); // @ts-ignore\n\n        if (account.accounts) {\n          var newPrefix = prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName; // @ts-ignore\n\n          return InstructionFormatter.flattenIdlAccounts( // @ts-ignore\n          account.accounts, newPrefix);\n        } else {\n          return _objectSpread(_objectSpread({}, account), {}, {\n            name: prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName\n          });\n        }\n      }).flat();\n    }\n  }]);\n\n  return InstructionFormatter;\n}();\n\nfunction sentenceCase(field) {\n  var result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}","map":{"version":3,"mappings":"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","names":["camelCase","borsh","bs58","IdlCoder","sighash","SIGHASH_STATE_NAMESPACE","SIGHASH_GLOBAL_NAMESPACE","InstructionCoder","idl","ixLayout","parseIxLayout","sighashLayouts","Map","instructions","forEach","ix","sh","name","set","encode","layout","get","state","methods","map","ixName","_encode","nameSpace","buffer","Buffer","alloc","methodName","len","data","slice","concat","encoding","from","decode","decoder","accountMetas","InstructionFormatter","format","stateMethods","ixLayouts","m","fieldLayouts","args","arg","fieldLayout","Array","accounts","_a","types","_b","struct","idlIx","filter","i","undefined","console","error","idlField","type","formatIdlType","formatIdlData","flatIdlAccounts","flattenIdlAccounts","meta","idx","length","idlType","vec","option","defined","toString","d","join","Error","filtered","t","formatIdlDataDefined","typeDef","kind","fields","Object","keys","k","f","variants","variant","enumType","namedFields","fieldData","v","variantName","pascalCase","prefix","account","accName","sentenceCase","newPrefix","flat","field","result","replace","charAt","toUpperCase"],"sourceRoot":"","sources":["../../../src/coder/instruction.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}