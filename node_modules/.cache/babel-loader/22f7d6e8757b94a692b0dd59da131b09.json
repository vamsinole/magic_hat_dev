{"ast":null,"code":"import * as assert from \"assert\";\nconst LOG_START_INDEX = \"Program log: \".length;\nexport class EventManager {\n  constructor(programId, provider, coder) {\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n\n  addEventListener(eventName, callback) {\n    let listener = this._listenerIdCount;\n    this._listenerIdCount += 1; // Store the listener into the event map.\n\n    if (!(eventName in this._eventCallbacks)) {\n      this._eventListeners.set(eventName, []);\n    }\n\n    this._eventListeners.set(eventName, this._eventListeners.get(eventName).concat(listener)); // Store the callback into the listener map.\n\n\n    this._eventCallbacks.set(listener, [eventName, callback]); // Create the subscription singleton, if needed.\n\n\n    if (this._onLogsSubscriptionId !== undefined) {\n      return listener;\n    }\n\n    this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n      if (logs.err) {\n        console.error(logs);\n        return;\n      }\n\n      this._eventParser.parseLogs(logs.logs, event => {\n        const allListeners = this._eventListeners.get(event.name);\n\n        if (allListeners) {\n          allListeners.forEach(listener => {\n            const [, callback] = this._eventCallbacks.get(listener);\n\n            callback(event.data, ctx.slot);\n          });\n        }\n      });\n    });\n    return listener;\n  }\n\n  async removeEventListener(listener) {\n    // Get the callback.\n    const callback = this._eventCallbacks.get(listener);\n\n    if (!callback) {\n      throw new Error(`Event listener ${listener} doesn't exist!`);\n    }\n\n    const [eventName] = callback; // Get the listeners.\n\n    let listeners = this._eventListeners.get(eventName);\n\n    if (!listeners) {\n      throw new Error(`Event listeners don't exist for ${eventName}!`);\n    } // Update both maps.\n\n\n    this._eventCallbacks.delete(listener);\n\n    listeners = listeners.filter(l => l !== listener);\n\n    if (listeners.length === 0) {\n      this._eventListeners.delete(eventName);\n    } // Kill the websocket connection if all listeners have been removed.\n\n\n    if (this._eventCallbacks.size == 0) {\n      assert.ok(this._eventListeners.size === 0);\n      await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n      this._onLogsSubscriptionId = undefined;\n    }\n  }\n\n}\nexport class EventParser {\n  constructor(programId, coder) {\n    this.coder = coder;\n    this.programId = programId;\n  } // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n\n\n  parseLogs(logs, callback) {\n    const logScanner = new LogScanner(logs);\n    const execution = new ExecutionContext(logScanner.next());\n    let log = logScanner.next();\n\n    while (log !== null) {\n      let [event, newProgram, didPop] = this.handleLog(execution, log);\n\n      if (event) {\n        callback(event);\n      }\n\n      if (newProgram) {\n        execution.push(newProgram);\n      }\n\n      if (didPop) {\n        execution.pop();\n      }\n\n      log = logScanner.next();\n    }\n  } // Main log handler. Returns a three element array of the event, the\n  // next program that was invoked for CPI, and a boolean indicating if\n  // a program has completed execution (and thus should be popped off the\n  // execution stack).\n\n\n  handleLog(execution, log) {\n    // Executing program is this program.\n    if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n      return this.handleProgramLog(log);\n    } // Executing program is not this program.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  } // Handles logs from *this* program.\n\n\n  handleProgramLog(log) {\n    // This is a `msg!` log.\n    if (log.startsWith(\"Program log:\")) {\n      const logStr = log.slice(LOG_START_INDEX);\n      const event = this.coder.events.decode(logStr);\n      return [event, null, false];\n    } // System log.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  } // Handles logs when the current program being executing is *not* this.\n\n\n  handleSystemLog(log) {\n    // System component.\n    const logStart = log.split(\":\")[0]; // Did the program finish executing?\n\n    if (logStart.match(/^Program (.*) success/g) !== null) {\n      return [null, true]; // Recursive call.\n    } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n      return [this.programId.toString(), false];\n    } // CPI call.\n    else if (logStart.includes(\"invoke\")) {\n      return [\"cpi\", false]; // Any string will do.\n    } else {\n      return [null, false];\n    }\n  }\n\n} // Stack frame execution context, allowing one to track what program is\n// executing for a given log.\n\nclass ExecutionContext {\n  constructor(log) {\n    // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n    const program = /^Program (.*) invoke.*$/g.exec(log)[1];\n    this.stack = [program];\n  }\n\n  program() {\n    assert.ok(this.stack.length > 0);\n    return this.stack[this.stack.length - 1];\n  }\n\n  push(newProgram) {\n    this.stack.push(newProgram);\n  }\n\n  pop() {\n    assert.ok(this.stack.length > 0);\n    this.stack.pop();\n  }\n\n}\n\nclass LogScanner {\n  constructor(logs) {\n    this.logs = logs;\n  }\n\n  next() {\n    if (this.logs.length === 0) {\n      return null;\n    }\n\n    let l = this.logs[0];\n    this.logs = this.logs.slice(1);\n    return l;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["assert","LOG_START_INDEX","length","EventManager","constructor","programId","provider","coder","_programId","_provider","_eventParser","EventParser","_eventCallbacks","Map","_eventListeners","_listenerIdCount","addEventListener","eventName","callback","listener","set","get","concat","_onLogsSubscriptionId","undefined","connection","onLogs","logs","ctx","err","console","error","parseLogs","event","allListeners","name","forEach","data","slot","removeEventListener","Error","listeners","delete","filter","l","size","ok","removeOnLogsListener","logScanner","LogScanner","execution","ExecutionContext","next","log","newProgram","didPop","handleLog","push","pop","stack","program","toString","handleProgramLog","handleSystemLog","startsWith","logStr","slice","events","decode","logStart","split","match","includes","exec"],"sourceRoot":"","sources":["../../../src/program/event.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}